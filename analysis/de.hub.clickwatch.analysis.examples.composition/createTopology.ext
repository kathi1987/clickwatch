
import SpecificMetaModel;
import topology;

cached createLink(Topology topology, Network network, link cw_link):
	let cw_source = network.node(cw_link.eContainer_entry.from):
	let cw_target = network.node(cw_link.to):
	let t_link = new topology::Link:
		topology.links.add(t_link) -> 
		t_link.setTarget(topology.createNode(cw_source)) -> 
		t_link.setSource(topology.createNode(cw_target)) -> 
		t_link.setPdr(cw_link.link_info.rev) -> t_link;
		
setReverseForLink(Topology topology, Link t_link):
	topology.links.select(l|l.source == t_link.target && l.target == t_link.source).first().setReverse(t_link) -> true;

cached createNode(Topology topology, SpecificMetaModel::Node cw_node):
	let t_node = new topology::Node:
		t_node.setIp(cw_node.iNetAddress) ->
		t_node.setMac(cw_node.mac()) -> 
		t_node;
		
cached node(Network network, String mac): 
	network.nodes.select(n|n.device_wifi.link_stat.bcast_stats.entry.from == mac).first();
	
linkStats(Node node):
	node.device_wifi.link_stat.bcast_stats.entry;
	
mac(SpecificMetaModel::Node node):
	node.linkStats().from;

links(Network network): 
	network.nodes.collect(n|n.linkStats().link).flatten();

performAnalysis(Network network):
	let topology = new Topology: 
		topology.nodes.addAll(network.nodes.collect(node|topology.createNode(node))) -> 
		topology.links.addAll(network.links().collect(link|topology.createLink(network, link))) -> 
		topology.links.forAll(l|topology.setReverseForLink(l)) -> 
		topology;