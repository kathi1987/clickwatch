\section{Related Work}
\label{sec:related_work}

\subsection{Model Persistence}
There are at least three different approaches to deal with large EMF models: (1) EMF resources, where a resource can be a file or an entry in a data base; (2) CDO~\cite{cdo} and other object relational mappings (ORM) for Ecore; (3) morsa~\cite{morsa2011} a EMF data-base mapping for non-relational data bases.

First, regular EMF: Models are persisted as XMI documents and can only be used if loaded completely into a computer's RAM. EMF realises the \emph{no fragmentation} strategy. The memory usage of EMF is linear to the model's size. It's time efficiency is good for small models, since it needs no further managing overhead, but is bad for large models due to pointless garbage collection and extensive allocation of memory.

First, EMF resources~\cite{emf2009}: EMF allows to fragment a model into different resources. Originally, each resource could only contain a separate containment hierarchy and only inter-resource cross-references were allowed. But since EMF version 2.2 containment proxies are supported. EMF support lazy loading: resources do not have to be loaded manually, EMF loads them transparently once objects of a resource are navigated to. Model objects have to be assigned to resources manually (\emph{manual fragmentation}). To actually save memory the user has to unload resources manually too. The framework MongoEMF~\cite{mongoEMF} maps resources to entries in a MongoDB~\cite{mongodb2010} data base.

Secondly, CDO~\cite{cdo}: CDO is a ORM for EMF.~\footnote{Lately, CDO also support non-relational data bases, such as MongoDB~\cite{mongodb2010}. Such features were not evaluated in this paper; but one can assume characteristics similar to those of morsa.}
It supports several relational data bases. Classes and features are mapped to tables and columns. CDO was designed for software modeling and provides transaction, views, and versions.
Relational data bases and SQL provide mechanisms to index and access objects with queries. This allows fast queries, if the user understands the underlying ORM.

Thirdly, morsa~\cite{morsa2011}: Different to CDO, morsa uses mongoDB~\cite{mongodb2010}, a no-sql data base. In no-sql data bases (also called key-value stores, see below) store arbitrary values in a key-value map. Morsa stores objects, their references and attributes as JSON documents. Morsa furthermore uses mongoDB's index feature to index specific characteristics (e.g. an objects meta-class reference).

\subsection{Key-Value Stores}

Web and cloud computing require scalability (replication and sharding) from a database, and traditional ACID~\cite{ACID} properties can be sacrificed if the data store is easily distributable. This explains the popularity of so called \emph{No-SQL} data bases or \emph{key-value stores}. Such key-value stores provide only a simple map data structure: there are only keys and values. For more information and an comparison of existing key-value stores refer to~\cite{nosql2010}.

Model fragmentation do not need complexly structured databases, since fragment contents can be serialized (e.g. with XMI) and fragments can be identified by keys (e.g. URIs). Key-value stores on the other hand provide good scalability for  large models (sharding, to partition data onto nodes in a peer-to-peer network) or for parallel access (replication, to duplicate data onto nodes in a peer-to-peer network).

There are three different applications that inspired three groups of key-value stores. First, there are web applications and the popular MongoDB~\cite{mongodb2010} and CouchDB~\cite{couchdb2010} data bases. These use JSON documents as values and provide additional indexing of JSON attributes.

Secondly, there is cloud computing and commercial Google Big-Table~\cite{bibtable2006} and Amazon's Dynamo~\cite{dynamo2007} inspired data stores. HBase~\cite{hbase2008} and Cassandra~\cite{cassandra2009} are respective open source implementations. Those data bases strive for massive distribution, they provide no support for indexing inner value attributes, but integrate well into map-reduce~\cite{mapreduce} execution frameworks, such as Hadoop (HBase is Hadoop's native data store). 

A third application is high performance computing. Scalaris~\cite{ScalarisTransactions2008} is a key-value store opt for massive parallel, cluster, and grid computing. Scalaris provides mechanisms for consistency and transactions and brings some ACID to key-value stores.