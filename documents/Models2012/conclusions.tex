\section{Future Work} 

\subsubsection{Sorted and Distributed Key-Value Stores} 

Our fragmentation strategy is based on unsorted key-value store accesses with $\mathcal{O}log$ complexity. Neither our analysis, nor out implementation EMFFrag, or our evaluation consider sorted key-value stores that allow to access sequential keys with constant time (scans). Neither did we consider distributed key-value stores which would allow parallel access. Key-value stores are easily distributed in peer two peer networks. This is done for two scalability reasons: replication (allows more users to access the same data in less time) and sharding (distributing data to allow faster and larger storage). Fragmentation can have an influence on both.

\subsubsection{Transactions}

If multiple user access/modify transactions become a necessity. Transaction can either be provided by the underlying data store (e.g. with Scalaris~\cite{ScalarisTransactions2008}) or can be implemented into EMFFrag. On non-distributed data stores, a common transaction pattern could be used. More interesting is explore the influence of fragmentation on transactions (and versioning), because the maximum granularity is determined by fragment size.

\subsubsection{Cross-References} 

EMFFrag persists containment references with URIs with a fragment ID pointing to the fragment that contains the reference objects. This does not work for cross references: when an object is moved, its URI changes and all referencing object use invalid URIs. For this reason EMFFrag needs to use a secondary index that maps object IDs to containing fragments. EMFFrag uses URIs with object IDs to persist cross references. To resolve such an URI, the secondary index is used to find the fragment that contains the object. Object IDs and secondary index are only maintained for objects that are actually cross references to keep the index small. 

In our analysis and evaluation, we did not examine the influence of cross references and corresponding indexes on performance. We have to expect that create/modify tasks are performed considerably slower, since two indexes have to be maintained. The impact on traverse, query, or partial loads, on the other hand, should be minimal.

\subsubsection{Large Value Sets}

In large models, single objects can become very large themselves if they hold large sets of attribute values and references. CDO maps an object's feature values to individual entries in a database table and can manage such objects, but does so slowly. EMFFrag (and Morsa), on the other hand, consider objects as atomic entities and large object become a performance burden too. We need to extend the fragmentation idea to large value sets. Similar to all consideration in this paper, these strategies for large value sets have to be optimized and evaluated for the abstract tasks manipulation, iteration (traverse), indexed access (query), and range queries (partial load). 

\section{Conclusions}\label{sec:conclusions}


\begin{itemize}

\item We proposed model fragmentation for model data base persistence with better performance characteristics that existing solutions (e.g. CDO, Morsa).

\item For most modelling tasks (create, traverse, query, partial load) fragmented models perform better or similar to existing solutions. For create, traverse, and partial load performance enhancements are of magnitudes.

\item Fragmentation can be achieved with meta-model based fragmentations, which already provides close to optimal performance for many applications and tasks (e.g. editing and compiling for software code models). Other strategies are imaginable and future work.

\item The downside is that the underlying key-value stores (generally) do not provide a transaction mechanism. Future work: implement transaction within EMFFrag or use key-value stores with transactions (e.g. Scalaris).

\item On the up-side, good scalarbility for both model size and demand for parallel access: e.g. in geo-spatial models. Good integration into parallel computing, i.e. with map-reduce frameworks.

\end{itemize}