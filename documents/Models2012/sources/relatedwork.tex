\section{Related Work}
\label{sec:related_work}

\subsection{Model Persistence}
EMF: Models are persisted as XMI documents and can only be used if loaded completely into a computer's main memory. EMF realizes the \emph{no fragmentation} strategy. The memory usage of EMF is linear to the model's size.

There are at least three different approaches to deal with large EMF models: (1) EMF resources, where a resource can be a file or an entry in a database; (2) CDO~\cite{cdo} and other object relational mappings (ORM) for Ecore; (3) morsa~\cite{morsa2011} a EMF data-base mapping for non-relational databases.

First, EMF resources~\cite{emf2009}: EMF allows clients to fragment a model into different resources. Originally, each resource could only contain a separate containment hierarchy and only inter-resource cross-references were allowed. But since EMF version 2.2 containment proxies are supported. EMF support lazy loading: resources do not have to be loaded manually, EMF loads them transparently once objects of a resource are navigated to. Model objects have to be assigned to resources manually (\emph{manual fragmentation}). To actually save memory the user has to unload resources manually too. The framework MongoEMF~\cite{mongoEMF} maps resources to entries in a MongoDB~\cite{mongodb2010} database.

Secondly, CDO~\cite{cdo}: CDO is a ORM for EMF.~\footnote{Lately, CDO also supports non-relational databases, such as MongoDB~\cite{mongodb2010}. Such features were not evaluated in this paper; but one can assume characteristics similar to those of Morsa.}
It supports several relational databases. Classes and features are mapped to tables and columns. CDO was designed for software modeling and provides transaction, views, and versions.
Relational databases provide mechanisms to index and access objects with SQL queries. This allows fast queries, if the user understands the underlying ORM.

Thirdly, morsa~\cite{morsa2011}: Different to CDO, Morsa uses mongoDB~\cite{mongodb2010}, a \emph{NoSQL} database that realizes a key-value store (see below). Morsa stores objects, their references and attributes as JSON documents. Morsa furthermore uses mongoDB's index feature to create and maintain indices for specific characteristics (e.g. an objects meta-class reference).

\subsection{Key-Value Stores}

Web and cloud computing require scaleability (replication and sharding\footnote{\emph{Sharding} denotes horizontal partitioning of a database, i.e. to put different parts of the data onto different nodes in the network} in a peer-to-peer network) from a database, and traditional ACID~\cite{ACID} properties can be sacrificed if the data store is easily distributeable. This explains the popularity of \emph{key-value stores}. Such stores provide only a simple map data structure: there are only keys and values. For more information and an comparison of existing key-value stores refer to~\cite{nosql2010}.

Model fragmentation does not need any complex database structure, since a fragment's content can be serialized (e.g. with XMI) and fragments can be identified by keys (e.g. URIs). Key-value stores on the other hand provide good scaleability for  large models (sharding) or for parallel access (replication).

There are three different applications that inspired three groups of key-value stores. First, there are web applications and the popular MongoDB~\cite{mongodb2010} and CouchDB~\cite{couchdb2010} databases. These use JSON documents as values and provide additional indexing of JSON attributes.

Secondly, there is cloud computing and commercial Google Big-Table~\cite{bigtable2006} and Amazon's Dynamo~\cite{dynamo2007} inspired data stores. HBase~\cite{hbase2008} and Cassandra~\cite{cassandra2009} are respective open source implementations. Those databases strive for massive distribution, they provide no support for indexing inner value attributes, but integrate well into map-reduce~\cite{mapreduce} execution frameworks, such as Hadoop (HBase is Hadoop's native data store). 

A third application is high performance computing. Scalaris~\cite{ScalarisTransactions2008} is a key-value store optimized for massive parallel, cluster, and grid computing. Scalaris provides mechanisms for consistency and transactions and brings some ACID to key-value stores.